	先想出一个思路，然后用算法实现，最后转换成计算机语言，最后是优化。
	数组应用--查表法--构造数组
	关键字都是小写
	自定义函数若无返回值，无输出语句则执行完以后消失（弹栈），其中的赋值语句相当于没有作用，因为内存被释放。
	private私有的只能在所属的类中访问到。{定义一个函数，函数里添加判断条件，从而达到门上加锁的目的}
	二维数组arr打印输出是地址。
	函数是否一样，看返回值，函数名，参数，和内容无关。
	一个类中若没有定义过构造函数，会有一个默认构造函数，目的是给对象初始化。
	函数重载包括参数顺序不一样。
	static定义的变量数据共享，改变就在以后用的时候都变了，并且随着类的存在而存在。
	静态代码块（加载一次，与类有关），构造代码块（加载很多次，与对象有关），局部代码块。
javadoc 识别文档注释。
	@（重点）单例设计模式（保证不需要创建对象，也创建不了对象，保证每个对象调用的值是一样的，要变都变）：三部曲：
1~private static Test t=new Test();//我自己在本类中创建一个对象，你用我的对象，这样是可控的，即受我控制
2~private Test(){}//构造函数私有化
3~private static Test getinstance(){
	return t;
}//提供一个让你使用我创建的对象的方法。
	调用时，不用创建对象，也不能创建对象（因为private）,直接Test t1 =Test.getinstance();//用我提供的方法。
	内存图解。
	单例设计模式，饿汉式（开发时较多），懒汉式（面试时较多，存在安全隐患，多线程）
	继承，覆盖的应用，当对代码进行优化时，一般不直接修改源代码，而是利用子父类继承。（super）
	子类中有默认的super();访问父类中的空参的构造函数。（子类的实例化过程），super,this 调用构造函数。（super,this,都必须写在第一行，所以只能有一个。）
	任何一个类默认继承，（extends Object）,Object上帝类，最大的。
	System.exit(0);退出虚拟机
	finally代码块通常用于释放资源
	
	javadoc:
		javadoc -d .(或者新建一个文件夹) -version（版本） -author(作者) Test.java
	final修饰的类不能被继承，修饰的方法不可以被覆盖，修饰的变量是一个常量，只能赋值一次。且final不固定默认初始化值。
	常量全大写，单词之间用下划线。
	有没有方法体就看有没有中括号。
	一个类可以继承另一个类的同时，实现多个接口。
	接口与接口之间是继承关系，而且可以多继承。（接口里没有方法体，不会产生不确定性）。
	抽象类既可以定义抽象方法，也可以定义非抽象方法，也可以不定义方法。
	先定义接口，再写程序，（先有接口，再有的电脑）
	父类 x =new 子类对象（多态，也叫上转型对象）
	对象的多态（上转型（猫提升为动物）对象）（猫既是猫，也是动物，子终为人父）animal a=new cat();//猫一提升为动物，作为动物去使用。所以前期定义的内容不能调用后期子类的特有内容
		弊端：前期定义的内容不能调用后期子类的特有内容。
		前提：要有覆盖（猫，狗，都吃东西）
	对象的向下转型（猫提升为动物以后再转为猫使用其特有的功能，动物不能抓老鼠）
		animal a=new cat();//上转型
		cat c=(cat)a;//下转型
		一直都是子类对象在转型。
	调用子类特有功能时，需要下转型，需要类型判断（防止动物转型时狗与猫对接）
		类型判断：
			if(a instanceof cat)
	变量//上转型对象编译，运行变量时都看等于号的左边//animal a=new cat();左边类中有就通过，没有，不通过
	方法//上转型对象编译方法看等号左边，运行看等号右边//
	静态方法//编译和运行都看左边//静态方法不需要创建对象，直接类名调用
	内部类：
		直接访问外部类的内部类成员//outer.inner in =new outer().new inner();{如果外部类和内部类中成员变量一样，调用所在类的}
		如果内部类是静态的，相当于一个外部类//outer.inner in=new outer.inner();
		如果内部类，成员均是静态的//outer.inner.function();
		局部内部类访问变量需要用final 修饰变量
		匿名内部类：前提//必须有个外部类或者父类或者接口（因为匿名没有名字无法new）
		格式：new Test(){//重写方法}.show();
		//区分this 和super
	  多catch中，异常父类放在最后catch//抛出必须在函数上声明//能处理就catch，不能处理的抛出
	异常类注意事项：
		子类在覆盖父类方法时，如果父类方法抛出了异常，子类的方法只能抛出父类的异常或者改异常的子类，如果父类抛出多个异常，子类只能抛出父类异常的子集。如果父类的方法没有抛出异常，那么子类覆盖时绝对不能抛出，只能try.
	object 所有类的根类（直接或者间接）